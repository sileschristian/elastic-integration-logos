const fs = require('fs');
const https = require('https');
const path = require('path');

/**
 * This script fetches all Elastic integrations from GitHub and generates a static logos.ts file.
 * Run this periodically (e.g., monthly) to update the logos list with new integrations.
 * 
 * Usage:
 *   npm run fetch-logos
 * 
 * Or with GitHub token for higher rate limits:
 *   GITHUB_TOKEN=your_token npm run fetch-logos
 */

// Fetch all packages from GitHub and find their logos
async function fetchAllLogos() {
  try {
    console.log('Fetching all packages from GitHub...');
    
    // Fetch all packages using pagination
    let allPackages = [];
    let page = 1;
    let hasMore = true;
    
    while (hasMore) {
      const url = `https://api.github.com/repos/elastic/integrations/contents/packages?per_page=100&page=${page}`;
      console.log(`Fetching page ${page}...`);
      
      const packages = await fetchJSON(url);
      
      if (!Array.isArray(packages)) {
        if (packages.message) {
          throw new Error(packages.message);
        }
        break;
      }
      
      const dirs = packages.filter(pkg => pkg.type === 'dir');
      allPackages.push(...dirs);
      console.log(`Found ${dirs.length} packages on page ${page} (total: ${allPackages.length})`);
      
      if (packages.length < 100) {
        hasMore = false;
      } else {
        page++;
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    console.log(`\nTotal packages found: ${allPackages.length}`);
    console.log('Finding logos for each package...\n');
    
    // Find logos for each package
    const logos = [];
    const batchSize = 10;
    
    for (let i = 0; i < allPackages.length; i += batchSize) {
      const batch = allPackages.slice(i, i + batchSize);
      const batchNum = Math.floor(i / batchSize) + 1;
      const totalBatches = Math.ceil(allPackages.length / batchSize);
      
      console.log(`Processing batch ${batchNum}/${totalBatches} (${i + 1}-${Math.min(i + batchSize, allPackages.length)})`);
      
      const batchPromises = batch.map(pkg => findLogoForPackage(pkg.name));
      const batchResults = await Promise.all(batchPromises);
      
      for (const logo of batchResults) {
        if (logo) {
          logos.push(logo);
        }
      }
      
      // Delay between batches
      if (i + batchSize < allPackages.length) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    // Sort by slug
    logos.sort((a, b) => a.slug.localeCompare(b.slug));
    
    console.log(`\nFound ${logos.length} logos out of ${allPackages.length} packages`);
    
    // Generate the logos.ts file
    const fileContent = `// This file is auto-generated by fetch-all-logos.js
// Run 'npm run fetch-logos' periodically to update this list with new integrations
// Last updated: ${new Date().toISOString()}

export const logos = [\n${logos.map(logo => 
      `    {\n        "slug": "${logo.slug}",\n        "logo": "${logo.logo}"\n    }`
    ).join(',\n')}\n  ];\n  \n  export default logos;\n`;
    
    const logosPath = path.join(__dirname, 'logos.ts');
    fs.writeFileSync(logosPath, fileContent);
    console.log(`\nâœ… Successfully generated logos.ts with ${logos.length} logos!`);
    console.log(`   File saved to: ${logosPath}`);
    console.log(`\n   Next steps:`);
    console.log(`   1. Review the generated logos.ts file`);
    console.log(`   2. Run 'npm run build' to rebuild the plugin`);
    console.log(`   3. Reload the plugin in Figma to see the updated integrations`);
    
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

async function findLogoForPackage(packageName) {
  try {
    // Try to fetch the img folder contents
    const imgUrl = `https://api.github.com/repos/elastic/integrations/contents/packages/${encodeURIComponent(packageName)}/img`;
    const imgFiles = await fetchJSON(imgUrl);
    
    if (!Array.isArray(imgFiles)) {
      return await tryAlternativeLogoLocations(packageName);
    }
    
    // Look for common logo file patterns (prioritized)
    const logoPatterns = [
      /^.*logo.*\.svg$/i,
      /^.*-logo.*\.svg$/i,
      /^logo.*\.svg$/i,
      /^icon.*\.svg$/i,
      /^.*\.svg$/i,
      /^.*logo.*\.png$/i,
      /^.*logo.*\.jpg$/i,
      /^.*logo.*\.jpeg$/i,
      /^icon.*\.png$/i,
    ];
    
    for (const pattern of logoPatterns) {
      const logoFile = imgFiles.find(file => 
        file.type === 'file' && pattern.test(file.name)
      );
      
      if (logoFile) {
        return {
          slug: packageName,
          logo: `https://raw.githubusercontent.com/elastic/integrations/main/packages/${encodeURIComponent(packageName)}/img/${encodeURIComponent(logoFile.name)}`
        };
      }
    }
    
    return await tryAlternativeLogoLocations(packageName);
  } catch (err) {
    return await tryAlternativeLogoLocations(packageName);
  }
}

async function tryAlternativeLogoLocations(packageName) {
  try {
    const rootUrl = `https://api.github.com/repos/elastic/integrations/contents/packages/${encodeURIComponent(packageName)}`;
    const rootFiles = await fetchJSON(rootUrl);
    
    if (Array.isArray(rootFiles)) {
      const logoFile = rootFiles.find(file => 
        file.type === 'file' && /\.(svg|png|jpg|jpeg)$/i.test(file.name) &&
        (/logo/i.test(file.name) || /icon/i.test(file.name))
      );
      
      if (logoFile) {
        return {
          slug: packageName,
          logo: `https://raw.githubusercontent.com/elastic/integrations/main/packages/${encodeURIComponent(packageName)}/${encodeURIComponent(logoFile.name)}`
        };
      }
    }
  } catch (err) {
    // Ignore errors
  }
  
  return null;
}

function fetchJSON(url) {
  return new Promise((resolve, reject) => {
    const headers = {
      'User-Agent': 'Elastic-Integration-Logos-Fetcher',
      'Accept': 'application/vnd.github.v3+json'
    };
    
    // Add GitHub token if provided as environment variable
    if (process.env.GITHUB_TOKEN) {
      headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
    }
    
    https.get(url, { headers }, (res) => {
      let data = '';
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        if (res.statusCode === 200) {
          try {
            resolve(JSON.parse(data));
          } catch (err) {
            reject(new Error('Failed to parse JSON'));
          }
        } else if (res.statusCode === 404) {
          reject(new Error('Not found'));
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data.substring(0, 200)}`));
        }
      });
    }).on('error', (err) => {
      reject(err);
    });
  });
}

fetchAllLogos();

